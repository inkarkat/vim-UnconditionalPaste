*UnconditionalPaste.txt* Force character-/line-/block-wise paste, regardless of how it was yanked.

		    UNCONDITIONAL PASTE    by Ingo Karkat
						      *UnconditionalPaste.vim*
description			|UnconditionalPaste-description|
usage				|UnconditionalPaste-usage|
installation			|UnconditionalPaste-installation|
configuration			|UnconditionalPaste-configuration|
limitations			|UnconditionalPaste-limitations|
known problems			|UnconditionalPaste-known-problems|
todo				|UnconditionalPaste-todo|
history				|UnconditionalPaste-history|

==============================================================================
DESCRIPTION				      *UnconditionalPaste-description*

If you're like me, you occasionally do a linewise yank, and then want to
insert that yanked text in the middle of some other line (or vice versa).
The mappings defined by this plugin will allow you to do a character-, line-,
or block-wise paste no matter how you yanked the text, both from normal and
insert mode.

Often, the register contents aren't quite in the form you need them. Maybe you
need to convert yanked lines to comma-separated arguments, maybe join the
lines with another separator, maybe the reverse: un-joining a single line on
some pattern to yield multiple lines. Though you can do the manipulation after
pasting, this plugin offers shortcut mappings for these actions, which are
especially helpful when you need to repeat the paste multiple times.

SOURCE									     *

Based on vimtip #1199 by cory,
    http://vim.wikia.com/wiki/Unconditional_linewise_or_characterwise_paste

SEE ALSO								     *

- |SubstituteExpression.vim| (vimscript #5596) provides the same flexible
  expression application of |g=p| to the moved-over / selected text / lines
  instead of register contents.

RELATED WORKS								     *

- whitespaste.vim (vimscript #4351) automatically removes blank lines around
  linewise contents, and condenses inner lines to a single one. By default, it
  remaps p / P, but this can be changed.

==============================================================================
USAGE						    *UnconditionalPaste-usage*
								   *gcp* *gcP*
["x]gcp, ["x]gcP	Paste characterwise (inner newline characters and
			indent are flattened to a single space, leading and
			trailing removed) [count] times.
								 *gcip* *gciP*
["x]gcip, ["x]gciP	Paste inline (inner newline characters and indent are
			kept, only leading and trailing removed) [count]
			times.
								 *gcgp* *gcgP*
["x]gcgp, ["x]gcgP	Paste joined (like |gJ|); indent and surrounding
			whitespace is kept as-is, [count] times.
								   *gCp* *gCP*
["x]gCp, ["x]gCP	Paste characterwise; any sequence of whitespace is
			flattened to a single space, leading and trailing
			indent removed, [count] times.
								   *glp* *glP*
["x]glp, ["x]glP	Paste linewise (even if yanked text is not a complete
			line) [count] times.
								   *gbp* *gbP*
["x]gbp, ["x]gbP	Paste blockwise (inserting multiple lines in-place,
			pushing existing text further to the right) [count]
			times. If there's only a single line to paste and no
			[count], first query about a separator pattern and
			un-join the register contents.

						       *g]p* *g[P* *g]P* *g[p*
["x]g]p, ["x]g[P  or	Paste linewise (even if yanked text is not a complete
	 ["x]g]P  or	line) [count] times like |glp|, but adjust the indent
	 ["x]g[p	to the current line (like |]p|).

								 *g]]p* *g]]P*
["x]g]]p, ["x]g]]P	Paste linewise below / above, with [count] more indent
			than the current line.			 *g[[p* *g[[P*
["x]g[[p, ["x]g[[P	Paste linewise below / above, with [count] less indent
			than the current line.
								   *g>p* *g>P*
["x]g>p, ["x]g>P	Paste lines with [count] times 'shiftwidth' indent.
			For characterwise and blockwise register contents,
			paste at the beginning / end of the line(s) with the
			indent before (|g>p|) / after (|g>P|) each line's
			content. Multiple characterwise lines are flattened
			into one as with |gcp|. The indent of blocks is based
			on the current line's width; if subsequent lines are
			longer, and additional indent is added there.
								   *g#p* *g#P*
["x]g#p, ["x]g#P	Paste linewise (even if yanked text is not a complete
			line) as commented text [count] times. This applies
			'commentstring' to each individual line, and adjusts
			the indent (of the entire comment) to the current line
			(like |]p|).
			This is useful when you want to paste indented text as
			comments, but avoid the progressive auto-indenting
			that would normally happen with |i_CTRL-R|.
								   *gsp* *gsP*
["x]gsp, ["x]gsP	Paste with [count] spaces (characterwise; blockwise:
			around each line; linewise: flattened like |gcp|)
			around the register contents. When pasting before the
			start or after the end of the line, or with whitespace
			around the current position, this is added only to the
			"other" side, unless there's emptyness at both sides.
			(Else, you could just use plain |p|/|P|.)
			Note: To paste with <Tab> instead of spaces (at the
			beginning or end), you can use |g>P| / |g>p| if you
			use tab-indenting or |gQP| / |gQp| (with the default
			separator) if 'expandtab' is set.	   *gSp* *gSP*
["x]gSp, ["x]gSP	Paste linewise (like |glp|) with [count] empty lines
			around the register contents. When pasting before the
			start or after the end of the buffer, or with empty
			lines around the current position, this is added only
			to the "other" side, unless there's emptyness at both
			sides. (Else, you could just use plain |p|/|P|.)
								   *gBp* *gBP*
["x]gBp, ["x]gBP	Paste as a minimal fitting (not rectangular) block
			with a jagged right edge; i.e. the lines
			"foobar\nhi\n" will be pasted as 6-character "foobar"
			in the current line and 2-character "hi" in the
			following one.
			With [count], each line's content is pasted [count]
			times.
			When pasting with |gBp| at the end of the line,
			appends at the jagged end of following lines.
			When pasting with |gBP| on the first non-indent
			character (after column 1) of a line, prepends after
			existing indent of following lines.
			If there's only a single line to paste and no [count],
			first query about a separator pattern and un-join the
			register contents.
								 *gqbp* *gqbP*
["x]gqbp, ["x]gqbP	Query for a separator string, then paste as a minimal
			fitting (not rectangular) block (like |gBp|) with that
			separator around each line (similar to |gqp|),
			omitting the separator at the start and end of the
			line or when there's already one at that side, like
			with |gsp|.
			With [count], each line's content is pasted [count]
			times, with the separator between each.
			When pasting with |gqbp| at the end of the line,
			appends (with separator) at the jagged end of
			following lines.
			When pasting with |gqbP| on the first non-indent
			character (after column 1) of a line, prepends (with
			separator) after existing indent of following lines.
			If there's only a single line to paste and no [count],
			first query about a separator pattern and un-join the
			register contents.
								 *gQBp* *gQBP*
["x]gQBp, ["x]gQBP	Paste blockwise with the previously queried (|gqbp|)
			separator string (and separator pattern, if single
			line). Defaults to <Tab> separator
			|g:UnconditionalPaste_Separator|.

								   *g,p* *g,P*
["x]g,p, ["x]g,P	Paste characterwise, with each line delimited by ", "
			instead of the newline (and indent).
				     *g,ap* *g,aP* *g,op* *g,oP* *g,np* *g,nP*
["x]g,ap, ["x]g,aP	Paste characterwise, with each line delimited by ", "
["x]g,op, ["x]g,oP	and the last line delimited by ", and" / ", or" / ",
["x]g,np, ["x]g,nP	nor" (and "neither" appended) instead of the newline
			(and indent).
			Cp. |g:UnconditionalPaste_IsSerialComma| for comma
			placement in front of the conjunction.

					   *g,'p* *g,'P* *g,quotep* *g,quoteP*
["x]g,'p, ["x]g,'P	Paste characterwise, with each line surrounded by
["x]g,"p, ["x]g,"P	single / double quotes and delimited by ", " instead
			of the newline (and indent).
								   *gqp* *gqP*
["x]gqp, ["x]gqP	Query for a separator string, then paste
			characterwise, with each line delimited by it.
			You can also additionally input a prefix (inserted
			once before the paste) and suffix (once after the
			paste) as {prefix}^M{separator}^M{suffix} (with ^M
			entered as <C-V><Enter>). There's another alternative
			form
	   {prefix}^M{element-prefix}^M{separator}^M{element-suffix}^M{suffix}
			that lets you specify prefixes and suffixes for each
			element.
			Examples:
			"^M, ^M"   -> "foo, bar, baz" ~

			"^M", "^M" -> "foo", "bar", "baz" ~
			can also be written as:
			^M"^M, ^M"^M -> "foo", "bar", "baz" ~

			Functions:^M^M - ^M()^M! -> Functions:foo() - bar() - baz()! ~

<			<ul>\n^M  <li>^M\n^M</li>^M\n</ul> -> <ul> ~
<							        <li>foo</li> ~
<							        <li>bar</li> ~
<							        <li>baz</li> ~
<							      </ul> ~
								   *gQp* *gQP*
["x]gQp, ["x]gQP	Paste characterwise, with each line delimited by the
			previously queried (|gqp|) separator string.
			Defaults to <Tab> separator
			|g:UnconditionalPaste_JoinSeparator|.
						   *gqgp* *gqgP* *gQgp* *gQgP*
["x]gqgp, ["x]gqgP	Like |gqp| / |gQp|, but keep indent and surrounding
["x]gQgp, ["x]gQgP	whitespace as-is; just join the lines with the
			separator (and prefix / suffix).

								 *gujp* *gujP*
["x]gujp, ["x]gujP	Query for a separator pattern, un-join the register
			contents, then paste linewise.
								 *gUJp* *gUJP*
["x]gUJp, ["x]gUJP	Un-join the register contents on the previously
			queried (|gujp|) separator pattern, then paste
			linewise. Defaults to separation by any whitespace and
			newlines |g:UnconditionalPaste_UnjoinSeparatorPattern|.

						     *grp* *grP* *gr!p* *gr!P*
["x]grp, ["x]grP	Query for a pattern, and only paste those lines that
			match the pattern.
["x]gr!p, ["x]gr!P	Query for a pattern, and only paste those lines that
			do NOT match the pattern.
			If there's only a single line to paste and no [count],
			first query about a separator pattern and un-join the
			register contents. Re-join all matches with the first
			match of the separator pattern and paste characterwise.
						     *gRp* *gRP* *gR!p* *gR!P*
["x]gRp, ["x]gRP	Only paste those lines that match the previously
			queried pattern.
["x]gR!p, ["x]gR!P	Only paste those lines that do NOT match the
			previously queried pattern.
			Both default to filter out whitespace-only lines
			|g:UnconditionalPaste_GrepPattern|
			|g:UnconditionalPaste_InvertedGrepPattern|.
			If there's only a single line to paste and no [count],
			un-join the register contents first like |gUJp|.
			Re-join all matches with the first match of the
			separator pattern and paste characterwise.
								   *g=p* *g=P*
["x]g=p, ["x]g=P	Query for an expression, and apply it to the register
			contents. The expression can be:
			- a Vimscript expression; |v:val| will contain the
			  register contents.
			- a function name (without parentheses); the function
			  will be passed the register contents as a single
			  String argument.
			- If the expression begins with '!', it will be
			  treated as an external command, and passed to the
			  |system()| function, with the register contents as
			  stdin. (To use an expression beginning with logical
			  not (|expr-!|), include a space before the '!'
			  character.)
			- If the expression begins with ':', the register
			  contents will be placed in a scratch buffer (of the
			  same 'filetype'), and the Ex command(s) will be
			  applied.
			- If the expression begins with /{pattern}/, each
			  match (of the last search pattern if empty) inside
			  the register contents is individually passed through
			  the following expression / function name / external
			  command / Ex command, then re-joined with the
			  separating non-matches in between.
			  When an expression returns a List, all elements are
			  joined with the first occurring separator in the
			  register contents.
			- If the expression begins with ^{pattern}^, the
			  register contents are split on {pattern} (last
			  search pattern if empty), and each item is
			  individually passed through the following expression
			  / function name / external command / Ex command,
			  then re-joined with the separators in between.
			  When an expression returns a List, all elements are
			  joined with the first separator match of {pattern} in
			  the register contents.
			- If the expression begins with ".", each individual
			  line (characterwise content can be multiplied into
			  lines via [count]) is passed through the following
			  expression / function name / external command / Ex
			  command. separators in between.
			  To omit a line through an expression, return an empty
			  List ([]). To expand a line into several, return a
			  List of lines.
								 *g==p* *g==P*
["x]g==p, ["x]g==P	Apply the previously queried expression to each line
			(replacing v:val with the current line), and paste the
			resulting lines.
								   *g\p* *g\P*
["x]g\p, ["x]g\P	Escape certain characters (global default /
			overridable per buffer |g:UnconditionalPaste_Escapes|;
			if none or multiple are configured query first, or
			take [count] to choose among multiples) and paste.
								 *g\\p* *g\\P*
["x]g\\p, ["x]g\\P	Escape the same characters as the last time and paste.

								   *gpp* *gpP*
["x]gpp, ["x]gpP	Paste with the first decimal number found on or after
			the current cursor column (or the overall first
			number, if no such match, or the last number, if the
			cursor is at the end of the line) incremented /
			decremented by 1.
			Do this [count] times, with each paste further
			incremented / decremented.
								   *gPp* *gPP*
["x]gPp, ["x]gPP	Paste with all decimal numbers incremented /
			decremented by 1.
			Do this [count] times, with each paste further
			incremented / decremented.
					   *gup* *guP* *gUp* *gUP* *g~p* *g~P*
["x]gup, ["x]guP	Paste with the first alphabetical character of the
			first / [count] word(s) made lowercase.
["x]gUp, ["x]gUP	Paste with the first alphabetical character of the
			first / [count] word(s) made uppercase.
["x]g~p, ["x]g~P	Paste with the first alphabetical character of the
			first / [count] word(s) toggled in case.
								   *ghp* *ghP*
["x]ghp, ["x]ghP	Paste with a queried combination of above mappings.
			The algorithm is the 1 or 2-character string between
			the g..p / g..P in the mappings. A [count] before
			|ghp| applies to each algorithm, you can override /
			supply a local [count], too.
                        EXAMPLES					     *
			- Uppercase a word and paste linewise:
			    ghpUc<Enter> ~
			- Unjoin words and paste as quoted list:
			    ghpuj,"<Enter><Space><Enter> ~
			- Paste line 3 times and indent:
			    ghp>3l<Enter> ~
			Note: Not all combinations make sense or work
			correctly.				   *gHp* *gHP*
["x]gHp, ["x]gHP	Paste with the previously queried combination of above
			mappings again. Defaults to linewise indented paste
			with empty lines around (|gSp| + |g>p|)
			|g:UnconditionalPaste_Combinations|.



CTRL-R CTRL-C {0-9a-z"%#*+/:.-}		   *i_CTRL-R_CTRL-C* *c_CTRL-R_CTRL-C*
			Insert the contents of a register characterwise
			(newline characters and indent are flattened to
			spaces).
			If you have options like 'textwidth', 'formatoptions',
			or 'autoindent' set, this will influence what will be
			inserted.
			Note: If the command-line mapping aborts
			the command line, try defining >
			    :cnoremap <C-c> <C-c>
<			or redefine the mapping.
CTRL-R CTRL-I {0-9a-z"%#*+/:.-}		   *i_CTRL-R_CTRL-I* *c_CTRL-R_CTRL-I*
			Insert the contents of a register inline (inner
			newline characters and indent are kept, only leading
			and trailing removed).
			     *i_CTRL-R_CTRL-C_CTRL-C* *c_CTRL-R_CTRL-C_CTRL-C*
CTRL-R CTRL-C CTRL-C {0-9a-z"%#*+/:.-}
			Insert the contents of a register characterwise; any
			sequence of whitespace is flattened to a single space,
			leading and trailing indent removed.
CTRL-R , {0-9a-z"%#*+/:.-}			     *i_CTRL-R_,* *c_CTRL-R_,*
			Insert the contents of a register characterwise, with
			each line delimited by ", " instead of the newline
			(and indent).
CTRL-R CTRL-Q {0-9a-z"%#*+/:.-}		   *i_CTRL-R_CTRL-Q* *c_CTRL-R_CTRL-Q*
			Query for a separator string, then insert the contents
			of a register characterwise, with each line delimited
			by it. Like |gqp|, but in insert mode.
			     *i_CTRL-R_CTRL-Q_CTRL-Q* *c_CTRL-R_CTRL-Q_CTRL-Q*
CTRL-R CTRL-Q CTRL-Q {0-9a-z"%#*+/:.-}
			Insert the contents of a register characterwise, with
			each line delimited by the previously queried (|gqp|,
			|i_CTRL-R_CTRL-Q|) separator string.
			     *i_CTRL-R_CTRL-Q_CTRL-G* *c_CTRL-R_CTRL-Q_CTRL-G*
 *i_CTRL-R_CTRL-Q_CTRL-Q_CTRL-G_CTRL-G* *c_CTRL-R_CTRL-Q_CTRL-Q_CTRL-G_CTRL-G*
CTRL-R CTRL-Q CTRL-G {0-9a-z"%#*+/:.-}
CTRL-R CTRL-Q CTRL-Q CTRL-G CTRL-G {0-9a-z"%#*+/:.-}
			Like CTRL-R CTRL-Q / CTRL-R CTRL-Q CTRL-Q, but keep
			indent and surrounding whitespace as-is; just join the
			lines with the separator (and prefix / suffix).

CTRL-R CTRL-U {0-9a-z"%#*+/:.-}		   *i_CTRL-R_CTRL-U* *c_CTRL-R_CTRL-U*
			Query for a separator pattern, un-join the contents of
			a register, then insert it linewise.
			     *i_CTRL-R_CTRL-U_CTRL-U* *c_CTRL-R_CTRL-U_CTRL-U*
CTRL-R CTRL-U CTRL-U {0-9a-z"%#*+/:.-}
			Un-join the contents of a register on the previously
			queried (|gujp|, |i_CTRL_R_CTRL-U|) pattern, then
			insert it linewise.

CTRL-R CTRL-\ {0-9a-z"%#*+/:.-}		   *i_CTRL-R_CTRL-\* *c_CTRL-R_CTRL-\*
			Escape certain characters (global default /
			overridable per buffer |g:UnconditionalPaste_Escapes|;
			if none or multiple are configured query first) and
                        insert. *i_CTRL-R_CTRL-\_CTRL-\* *c_CTRL-R_CTRL-\_CTRL-\*
CTRL-R CTRL-\ CTRL-\ {0-9a-z"%#*+/:.-}
			Escape the same characters as the last time and
			insert.
						     *i_CTRL-R_~* *c_CTRL-R_~*
CTRL-R ~ {0-9a-z"%#*+/:.-}
			Insert the contents of a register, toggling the case
			of the first alphabetical character of the first word.
			Like |g~p| / |g~p|, but in insert mode.

					   *i_CTRL-R_CTRL-H* *c_CTRL-R_CTRL-H*
CTRL-R CTRL-H {0-9a-z"%#*+/:.-}
			Query for a combination of UnconditionalPaste
			mappings, apply those to the contents of the register,
			and insert the result.
			     *i_CTRL-R_CTRL-H_CTRL-H* *c_CTRL-R_CTRL-H_CTRL-H*
CTRL-R CTRL-H CTRL-H {0-9a-z"%#*+/:.-}
			Apply the last queried combination of
			UnconditionalPaste mappings to the contents of the
			register again, and insert the result.

==============================================================================
INSTALLATION				     *UnconditionalPaste-installation*

The code is hosted in a Git repo at
    https://github.com/inkarkat/vim-UnconditionalPaste
You can use your favorite plugin manager, or "git clone" into a directory used
for Vim |packages|. Releases are on the "stable" branch, the latest unstable
development snapshot on "master".

This script is also packaged as a |vimball|. If you have the "gunzip"
decompressor in your PATH, simply edit the *.vmb.gz package in Vim; otherwise,
decompress the archive first, e.g. using WinZip. Inside Vim, install by
sourcing the vimball or via the |:UseVimball| command. >
    vim UnconditionalPaste*.vmb.gz
    :so %
To uninstall, use the |:RmVimball| command.

DEPENDENCIES				     *UnconditionalPaste-dependencies*

- Requires Vim 7.0 or higher.
- Requires the |ingo-library.vim| plugin (vimscript #4433), version 1.044 or
  higher.
- repeat.vim (vimscript #2136) plugin (optional)
- |AlignFromCursor.vim| plugin (vimscript #4155), version 2.02 or higher
  (optional).

==============================================================================
CONFIGURATION				    *UnconditionalPaste-configuration*

For a permanent configuration, put the following commands into your |vimrc|:
					      *g:UnconditionalPaste_Separator*
The default separator string for the |gQBp| mapping is a <Tab> character; to
preset another one (it will be overridden by |gqbp|), use: >
    let g:UnconditionalPaste_Separator = 'text'
<
					  *g:UnconditionalPaste_JoinSeparator*
The default separator string for the |gQp| and |i_CTRL-R_CTRL-Q_CTRL-Q|
mappings is a <Tab> character; to preset another one (it will be overridden by
|gqp| and |i_CTRL-R_CTRL-Q|), use: >
    let g:UnconditionalPaste_JoinSeparator = 'text'
<
				 *g:UnconditionalPaste_UnjoinSeparatorPattern*
The default separator pattern for the |gUJp| and |i_CTRL-R_CTRL-U_CTRL-U|
mappings matches any whitespace and newlines (i.e. it will get rid of empty
lines); to preset another one (it will be overridden by |gujp| and
|i_CTRL-R_CTRL-U|), use: >
    let g:UnconditionalPaste_UnjoinSeparatorPattern = '-'
<
 *g:UnconditionalPaste_GrepPattern* *g:UnconditionalPaste_InvertedGrepPattern*
The default pattern for the |gRp| and |gR!p| mappings filter out
whitespace-only lines; to preset another one (will be overridden by |grp| /
|gr!p|), use: >
    let g:UnconditionalPaste_GrepPattern = 'pattern'
    let g:UnconditionalPaste_InvertedGrepPattern = 'pattern'
<
				 *g:UnconditionalPaste_IsFullLineRetabOnShift*
The |g>p| / |g>P| mappings uses the |AlignFromCursor.vim| plugin's
functionality (if installed) to only affect the whitespace between the
original text and the pasted line. If you want to always |:retab|! all the
whitespace in the entire line, disable this via: >
    let g:UnconditionalPaste_IsFullLineRetabOnShift = 1
<
					  *g:UnconditionalPaste_IsSerialComma*
By default, the |g,ap|, |g,op|, and |g,np| mappings use a comma immediately
before the coordinating conjunction (also known as "Oxford comma"; unless
exactly two lines are pasted); to turn this off: >
    let g:UnconditionalPaste_IsSerialComma = 0
<
*g:UnconditionalPaste_EmptySeparatorPattern* *b:UnconditionalPaste_EmptySeparatorPattern*
By default, the |gsp| mapping does not insert a space on a side that already
has whitespace. You can make other separators (e.g. quotes) be considered as
existing space by tweaking the regular expression in : >
    let g:UnconditionalPaste_EmptySeparatorPattern = '\s'
For some cases (like avoiding a space when pasting inside a {...}) it matters
whether the separator is before or after the paste. Instead of a single
pattern, you can pass a List of two patterns there; the first one applies to
separators before the paste (so it could match a { if you don't want a space
when pasting after it, but you do want a space when pasting before it), the
second applies to separators after the paste: >
    let g:UnconditionalPaste_EmptySeparatorPattern = ['[[:space:]{]', '[[:space:]}]']
<
*g:UnconditionalPaste_EmptyLinePattern* *b:UnconditionalPaste_EmptyLinePattern*
By default, the |gSp| mapping does not add an empty line on a side that
already just consists of whitespace. You can make other lines be considered
empty by tweaking the regular expression: >
    let g:UnconditionalPaste_EmptyLinePattern = '^\s*$'
For some cases (like avoiding an empty line when pasting inside a { ... }
block) it matters whether the line is above or below the paste. Instead of a
single pattern, you can pass a List of two patterns there; the first one
applies to lines above the paste (so it could match a { if you don't want an
empty line when pasting after it, but you do want an empty line when pasting
before it), the second applies to lines below the paste: >
    let g:UnconditionalPaste_EmptyLinePattern = ['^\s*{\?$', '^\s*}\?$']
<
		 *g:UnconditionalPaste_Escapes* *b:UnconditionalPaste_Escapes*
By default, the |g\p| and |i_CTRL-R_CTRL-\| mappings escape backslashes. You
can change that (e.g. to also escape double quotes), or add more variants: >
    let g:UnconditionalPaste_Escapes = [{
    \   'name': 'dquote',
    \   'pattern': '[\"]',
    \   'replacement': '\\&'
    \}, ...]
Each configuration object attributes is optional; alternatively, you can also
specify an expression (using v:val), or a Funcref that takes and returns a
String: >
    let g:UnconditionalPaste_Escapes = [
    \   {'Replacer': 'tr(v:val, "o", "X")'},
    \   {'Replacer': function('MyReplacer')},
    \...]
The buffer-local |b:UnconditionalPaste_Escapes| overrides that for particular
buffers (filetypes if placed in a ftplugin).
						 *g:UnconditionalPaste_Escape*
This stores the last replacement used for |g\\p| and |i_CTRL_R_CTRL-\|.
It is initialized with the first escape from the above configuration / entered
/ selected escape.

					   *g:UnconditionalPaste_Combinations*
The default combination used for the |gHp| and |i_CTRL-R_CTRL-H_CTRL-H|
mappings. Must be a List of 1 or 2-character strings between the g..p / g..P
in the mappings; best obtained by selecting the desired algorithms via |ghp|
once and then grabbing the variable value: >
    let g:UnconditionalPaste_Combinations = ['U', ',"', 's']
<

					    *g:UnconditionalPaste_no_mappings*
If you want no or only a few of the available mappings, you can completely
turn off the creation of the default mappings by defining: >
    :let g:UnconditionalPaste_no_mappings = 1
This saves you from mapping dummy keys to all unwanted mapping targets.
						    *UnconditionalPaste-remap*
If you want to use different mappings (e.g. starting with <Leader>), map your
keys to the <Plug>UnconditionalPaste... mapping targets _before_ sourcing this
script (e.g. in your |vimrc|): >
    nmap <Leader>Pc <Plug>UnconditionalPasteCharBefore
    nmap <Leader>pc <Plug>UnconditionalPasteCharAfter
    nmap <Leader>Pn <Plug>UnconditionalPasteInlinedBefore
    nmap <Leader>pn <Plug>UnconditionalPasteInlinedAfter
    nmap <Leader>Pj <Plug>UnconditionalPasteJustJoinedBefore
    nmap <Leader>pj <Plug>UnconditionalPasteJustJoinedAfter
    nmap <Leader>PC <Plug>UnconditionalPasteCharCondensedBefore
    nmap <Leader>pC <Plug>UnconditionalPasteCharCondensedAfter
    nmap <Leader>Pl <Plug>UnconditionalPasteLineBefore
    nmap <Leader>pl <Plug>UnconditionalPasteLineAfter
    nmap <Leader>Pb <Plug>UnconditionalPasteBlockBefore
    nmap <Leader>pb <Plug>UnconditionalPasteBlockAfter
    nmap <Leader>Pi <Plug>UnconditionalPasteIndentedBefore
    nmap <Leader>pi <Plug>UnconditionalPasteIndentedAfter
    nmap <Leader>Pm <Plug>UnconditionalPasteMoreIndentBefore
    nmap <Leader>pm <Plug>UnconditionalPasteMoreIndentAfter
    nmap <Leader>Pl <Plug>UnconditionalPasteLessIndentBefore
    nmap <Leader>pl <Plug>UnconditionalPasteLessIndentAfter
    nmap <Leader>P> <Plug>UnconditionalPasteShiftedBefore
    nmap <Leader>p> <Plug>UnconditionalPasteShiftedAfter
    nmap <Leader>P# <Plug>UnconditionalPasteCommentedBefore
    nmap <Leader>p# <Plug>UnconditionalPasteCommentedAfter
    nmap <Leader>Ps <Plug>UnconditionalPasteSpacedBefore
    nmap <Leader>ps <Plug>UnconditionalPasteSpacedAfter
    nmap <Leader>PS <Plug>UnconditionalPasteParagraphedBefore
    nmap <Leader>pS <Plug>UnconditionalPasteParagraphedAfter
    nmap <Leader>PB <Plug>UnconditionalPasteJaggedBefore
    nmap <Leader>pB <Plug>UnconditionalPasteJaggedAfter
    nmap <Leader>Pd <Plug>UnconditionalPasteDelimitedBefore
    nmap <Leader>pd <Plug>UnconditionalPasteDelimitedAfter
    nmap <Leader>PD <Plug>UnconditionalPasteRecallDelimitedBefore
    nmap <Leader>pD <Plug>UnconditionalPasteRecallDelimitedAfter
    nmap <Leader>P, <Plug>UnconditionalPasteCommaBefore
    nmap <Leader>p, <Plug>UnconditionalPasteCommaAfter
    nmap <Leader>P' <Plug>UnconditionalPasteCommaSingleQuoteBefore
    nmap <Leader>p' <Plug>UnconditionalPasteCommaSingleQuoteAfter
    nmap <Leader>P" <Plug>UnconditionalPasteCommaDoubleQuoteBefore
    nmap <Leader>p" <Plug>UnconditionalPasteCommaDoubleQuoteAfter
    nmap <Leader>P,n <<Plug>UnconditionalPasteCommaNorBefore
    nmap <Leader>p,n <Plug>UnconditionalPasteCommaNorAfter
    nmap <Leader>P,o <Plug>UnconditionalPasteCommaOrBefore
    nmap <Leader>p,o <Plug>UnconditionalPasteCommaOrAfter
    nmap <Leader>P,a <Plug>UnconditionalPasteCommaAndBefore
    nmap <Leader>p,a <Plug>UnconditionalPasteCommaAndAfter
    nmap <Leader>Pq <Plug>UnconditionalPasteQueriedBefore
    nmap <Leader>pq <Plug>UnconditionalPasteQueriedAfter
    nmap <Leader>PQ <Plug>UnconditionalPasteRecallQueriedBefore
    nmap <Leader>pQ <Plug>UnconditionalPasteRecallQueriedAfter
    nmap <Leader>Pgq <Plug>UnconditionalPasteQueriedJoinedBefore
    nmap <Leader>pgq <Plug>UnconditionalPasteQueriedJoinedAfter
    nmap <Leader>PgQ <Plug>UnconditionalPasteRecallQueriedJoinedBefore
    nmap <Leader>pgQ <Plug>UnconditionalPasteRecallQueriedJoinedAfter
    nmap <Leader>Puj <Plug>UnconditionalPasteUnjoinBefore
    nmap <Leader>puj <Plug>UnconditionalPasteUnjoinAfter
    nmap <Leader>PUJ <Plug>UnconditionalPasteRecallUnjoinBefore
    nmap <Leader>pUJ <Plug>UnconditionalPasteRecallUnjoinAfter
    nmap <Leader>Pr <Plug>UnconditionalPasteGrepBefore
    nmap <Leader>pr <Plug>UnconditionalPasteGrepAfter
    nmap <Leader>P! <Plug>UnconditionalPasteInvertedGrepBefore
    nmap <Leader>p! <Plug>UnconditionalPasteInvertedGrepAfter
    nmap <Leader>PR <Plug>UnconditionalPasteRecallGrepBefore
    nmap <Leader>pR <Plug>UnconditionalPasteRecallGrepAfter
    nmap <Leader>P1 <Plug>UnconditionalPasteRecallInvertedGrepBefore
    nmap <Leader>p1 <Plug>UnconditionalPasteRecallInvertedGrepAfter
    nmap <Leader>Pe <Plug>UnconditionalPasteExpressionBefore
    nmap <Leader>pe <Plug>UnconditionalPasteExpressionAfter
    nmap <Leader>PE <Plug>UnconditionalPasteRecallExpressionBefore
    nmap <Leader>pE <Plug>UnconditionalPasteRecallExpressionAfter
    nmap <Leader>Px <Plug>UnconditionalPasteEscapeBefore
    nmap <Leader>px <Plug>UnconditionalPasteEscapeAfter
    nmap <Leader>PX <Plug>UnconditionalPasteRecallEscapeBefore
    nmap <Leader>pX <Plug>UnconditionalPasteRecallEscapeAfter
    nmap <Leader>Pp <Plug>UnconditionalPastePlusBefore
    nmap <Leader>pp <Plug>UnconditionalPastePlusAfter
    nmap <Leader>PP <Plug>UnconditionalPasteGPlusBefore
    nmap <Leader>pP <Plug>UnconditionalPasteGPlusAfter
    nmap <Leader>Pu <Plug>UnconditionalPasteLowercaseBefore
    nmap <Leader>pu <Plug>UnconditionalPasteLowercaseAfter
    nmap <Leader>PU <Plug>UnconditionalPasteUppercaseBefore
    nmap <Leader>pU <Plug>UnconditionalPasteUppercaseAfter
    nmap <Leader>pt <Plug>UnconditionalPasteTogglecaseBefore
    nmap <Leader>Pt <Plug>UnconditionalPasteTogglecaseAfter
    nmap <Leader>Ph <Plug>UnconditionalPasteCombinatorialBefore
    nmap <Leader>ph <Plug>UnconditionalPasteCombinatorialAfter
    nmap <Leader>PH <Plug>UnconditionalPasteRecallCombinatorialBefore
    nmap <Leader>pH <Plug>UnconditionalPasteRecallCombinatorialAfter

    imap <C-G>c <Plug>UnconditionalPasteCharI
    imap <C-G>n <Plug>UnconditionalPasteInlinedI
    imap <C-G>C <Plug>UnconditionalPasteCharCondensedI
    imap <C-G>, <Plug>UnconditionalPasteCommaI
    imap <C-G>q <Plug>UnconditionalPasteQueriedI
    imap <C-G>Q <Plug>UnconditionalPasteRecallQueriedI
    imap <C-G>j <Plug>UnconditionalPasteQueriedJoinedI
    imap <C-G>J <Plug>UnconditionalPasteRecallQueriedJoinedI
    imap <C-G>u <Plug>UnconditionalPasteUnjoinI
    imap <C-G>U <Plug>UnconditionalPasteRecallUnjoinI
    imap <C-G>x <Plug>UnconditionalPasteEscapeI
    imap <C-G>X <Plug>UnconditionalPasteRecallEscapeI
    imap <C-G>~ <Plug>UnconditionalPasteTogglecaseI
    imap <C-G>h <Plug>UnconditionalPasteCombinatorialI
    imap <C-G>H <Plug>UnconditionalPasteRecallCombinatorialI

    cmap <C-G>c <Plug>UnconditionalPasteCharI
    cmap <C-G>n <Plug>UnconditionalPasteInlinedI
    cmap <C-G>C <Plug>UnconditionalPasteCharCondensedI
    cmap <C-G>, <Plug>UnconditionalPasteCommaI
    cmap <C-G>q <Plug>UnconditionalPasteQueriedI
    cmap <C-G>Q <Plug>UnconditionalPasteRecallQueriedI
    cmap <C-G>j <Plug>UnconditionalPasteQueriedJoinedI
    cmap <C-G>J <Plug>UnconditionalPasteRecallQueriedJoinedI
    cmap <C-G>u <Plug>UnconditionalPasteUnjoinI
    cmap <C-G>U <Plug>UnconditionalPasteRecallUnjoinI
    cmap <C-G>x <Plug>UnconditionalPasteEscapeI
    cmap <C-G>X <Plug>UnconditionalPasteRecallEscapeI
    cmap <C-G>~ <Plug>UnconditionalPasteTogglecaseI
    cmap <C-G>h <Plug>UnconditionalPasteCombinatorialI
    cmap <C-G>H <Plug>UnconditionalPasteRecallCombinatorialI
<
==============================================================================
LIMITATIONS				      *UnconditionalPaste-limitations*

KNOWN PROBLEMS				   *UnconditionalPaste-known-problems*

TODO						     *UnconditionalPaste-todo*

IDEAS						    *UnconditionalPaste-ideas*

CONTRIBUTING				       *UnconditionalPaste-contribute*

Report any bugs, send patches, or suggest features via the issue tracker at
https://github.com/inkarkat/vim-UnconditionalPaste/issues or email (address
below).

==============================================================================
HISTORY						  *UnconditionalPaste-history*

4.40	RELEASEME
- CHG: g=p and g==p apply the expression to the whole register contents, not
  to individual lines. Instead, the expression can now be applied individually
  to matches of prepended /{pattern}/, or to items separated by ^{pattern}^,
  or via prepended "." to individual lines. So, to keep the previous behavior,
  just put a "." before the expression. Because of that change, single lines
  are not unjoined by a queried pattern any longer; ^{pattern}^ can be used.
- ENH; g=p and g==p support specifying a function name ("toupper" instead of
  "toupper(v:val)"), and filtering through external command or Ex command (in
  a scratch buffer). This achieves feature parity and consistency
  with.SubstituteExpression.vim's g={motion} and g== mappings.
  *** You need to update to ingo-library (vimscript #4433) version 1.044! ***

4.30	05-Sep-2020
- ENH: Add gHp mapping for repeating the same previously queried combination
  and a configurable preset g:UnconditionalPaste_Combinations.
- ENH: Add i_CTRL-R_CTRL-H / c_CTRL-R_CTRL-H mappings for ghp and
  i_CTRL-R_CTRL-H_CTRL-H / c_CTRL-R_CTRL-H_CTRL-H for gHp. As only some paste
  variants are offered in insert and command-line modes, these allow to use
  any (working) variant there, too, and any combinations of them.
- BUG: Empty line check in gSp does not account for a closed fold under cursor
  and wrongly considers the current line within the fold instead of the first
  / last folded line.
- ENH: Allow to disable all default mappings via a single
  g:UnconditionalPaste_no_mappings configuration flag.
- ENH: Add gCp and i_CTRL-R_CTRL-C_CTRL-C variants of gcp and i_CTRL-R_CTRL-C
  that flatten any sequence of whitespace to a single space; so not just
  indent, but also inner runs of whitespace.
- ENH: Add gcip and i_CTRL-R_CTRL-I variants of gcp and i_CTRL-R_CTRL-C
  that just paste inline (so linewise and blockwise register contents are not
  put on separate lines, but start at the cursor position), but keep inner
  newlines and their indent (so not all is flattened into a single line).
- ENH: gsp lets users tweak which sides do not get a space inserted via
  g:UnconditionalPaste_EmptySeparatorPattern.
- ENH: gSp also considers whitespace-only lines as empty (not just totally
  empty ones) by default, and lets users tweak that via
  g:UnconditionalPaste_EmptyLinePattern.
- BUG: gSP / gSp on completely empty buffer does not add both leading and
  trailing empty lines.
- BUG: gSP / gSp on single line in buffer do not consider start / end of buffer.

4.20	24-Jan-2018
- Add JustJoined (gcgp) and QueriedJoined (gqgp, <C-q><C-g>) variants of gcp
  and gqp that keep indent and surrounding whitespace as-is.
- CHG: Insert and command-line mode <Plug> mappings now have a trailing I, to
  resolve the ambiguity between <Plug>UnconditionalPasteQueried and
  <Plug>UnconditionalPasteQueriedJoined. **** Please update any insert- and
  command-line mode mapping customization. ****
- Add CommaAnd (g,ap), CommaOr (g,op), and CommaNor (g,np) variants of g,p.
- Add Escape (g\p, i_CTRL-R_CTRL-\) and RecallEscape (g\\p,
  i_CTRL-R_CTRL-\_CTRL-\) mappings to perform escaping of certain characters
  before pasting / inserting.

4.10	23-Dec-2016
- Add grp / gr!p / gRp / gR!p mappings that include / exclude lines matching
  queried / recalled pattern, defaulting (both variants) to include only
  non-empty lines.
- Add g=p / g==p mappings that process lines through a queried / recalled Vim
  expression.
- ENH: In ghp query, offer help on the mnemonics by pressing ?.
- ENH: Make gqp also support 5-element
  {prefix}^M{element-prefix}^M{separator}^M{element-suffix}^M{suffix} in
  addition to the 3-element one.
  *** You need to update to ingo-library (vimscript #4433) version 1.026! ***

4.00	09-Aug-2016
- Establish hard dependency on ingo-library. *** You need to separately
  install ingo-library (vimscript #4433) version 1.024 (or higher)! ***
- BUG: Escaped characters like \n are handled inconsistently in gqp: resolved
  as {separator}, taken literally in {prefix} and {suffix}. Use
  ingo#cmdargs#GetUnescapedExpr() to resolve them (also for gqbp, which only
  supports {separator}).
- ENH: If there's only a single line to paste and no [count] with the
  blockwise commands (gbp, gBp, gqbq, gQBp), first query about a separator
  pattern and un-join the register contents. Otherwise, these variants don't
  make much sense (and for the corner cases, a count of 1 can be supplied).
- CHG: Split off |gSp| from |gsp|; the latter now flattens line(s) like |gcp|,
  whereas the new |gSp| forces linewise surrounding with empty lines. I found
  that I often |dd| a line in order to append it to another line with a space
  in between.
- CHG: Change gup / gUp to gujp / gUJp and add gup / gUp to lower / uppercase
  the first character of the register
- Need to use temporary default register also for the built-in read-only
  registers {:%.}.
- FIX: Vim error on CTRL-R ... mappings incorrectly inserted "0". Need to
  return '' from :catch.
- Add ghp / ghP combinatorial type that queries and then sequentially applies
  multiple algorithms.

3.10	23-Dec-2014
- Add g,'p and g,"p variants of g,p.
- ENH: Allow to specify prefix and suffix when querying for the separator
  string in gqp and i_CTRL-R_CTRL-Q.

3.03	03-Dec-2014
- BUG: gsp / gsP border check adds spaces on both sides when there's a single
  character in line (like when there's a completely empty line, where this
  would be correct). Differentiate between empty and single-char line and then
  clear the isAtStart / isAtEnd flag not in the direction of the paste.

3.02	19-Jun-2014
- CHG: Change default mappings of gdp and gDp to gqbp and gQBp, respectively,
  to avoid slowing down the built-in |gd| and |gD| commands with a wait for
  the mapping timeout. Though the new defaults are one keystroke longer, they
  are a better mnemonic (combining gqp and gBp), and this is a rather obscure
  mapping, anyway.

3.01	23-May-2014
- For gsp, remove surrounding whitespace (characterwise) / empty lines
  (linewise) before adding the spaces / empty lines. This ensures a more
  dependable and deterministic DWIM behavior.

3.00	24-Mar-2014
- ENH: Extend CTRL-R insert mode mappings to command-line mode.
- When doing gqp / q,p of a characterwise or single line, put the separator in
  front (gqp) / after (gqP); otherwise, the mapping is identical to normal p /
  P and therefore worthless.
- Add g#p mapping to apply 'commentstring' to each indented linewise paste.
- Add gsp mapping to paste with [count] spaces / empty lines around the
  register contents.
- Add gdp / gDp mappings to paste as a minimal fitting block with (queried /
  recalled) separator string, with special cases at the end of leading indent
  and at the end of the line.
- Add gBp mapping to paste as a minimal fitting block with jagged right edge,
  a separator-less variant of gDp.
- Add g>p mapping to paste shifted register contents.
- Add g]]p and g[[p mappings to paste like with g]p, but with more / less
  indent.

2.21	23-Apr-2013
- FIX: In gpp and gPp, keep leading zeros when incrementing the number.
- FIX: In gpp and gPp, do not interpret leading zeros as octal numbers when
  incrementing.

2.20	18-Mar-2013
- ENH: gpp also handles multi-line pastes. A number (after the corresponding
  column) is incremented in every line. If there are no increments this way,
  fall back to replacement of the first occurrence.
- ENH: Add gPp / gPP mappings to paste with all numbers incremented /
  decremented.
- ENH: Add g]p / g]P mappings to paste linewise with adjusted indent. Thanks
  to Gary Fixler for the suggestion.

2.10	22-Dec-2012
- ENH: Add gpp / gpP mappings to paste with one number (which depending on the
  current cursor position) incremented / decremented.
- FIX: For characterwise pastes with a [count], the multiplied pastes must be
  joined with the desired separator, not just plainly concatenated.
- FIX: Don't lose the original [count] given when repeating the mapping.
- FIX: Do not re-query on repeat of the mapping.

2.00	05-Dec-2012
- ENH: Add g,p / gqp / gQp mappings to paste lines flattened with comma,
  queried, or recalled last used delimiter.
- ENH: Add gup / gUp mappings to paste unjoined register with queried or
  recalled last used delimiter pattern.
- ENH: Add CTRL-R CTRL-C mapping to insert register contents characterwise
  (flattened) from insert mode, and similar insert mode mappings for the other
  new mappings.
- CHG: Flatten all whitespace and newlines before, after, and around lines
  when pasting characterwise or joined.

1.22	04-Dec-2012
- BUG: When repeat.vim is not installed, the mappings do nothing. Need to
  :execute the :silent! call of repeat.vim to avoid that the remainder of the
  command line is aborted together with the call.
- Using separate autoload script to help speed up Vim startup.

1.21	02-Dec-2011
- ENH: When pasting a blockwise register as lines, strip all trailing
  whitespace. This is useful when cutting a block of text from a column-like
  text and pasting as new lines.
- ENH: When pasting a blockwise register as characters, flatten and shrink all
  trailing whitespace to a single space.

1.20	30-Sep-2011
BUG: Repeat always used the unnamed register. Add register registration to
enhanced repeat.vim plugin. This also handles repetition when used together
with the expression register "=. Requires a so far inofficial update to
repeat.vim version 1.0 (that hopefully makes it into upstream), which is
available at https://github.com/inkarkat/vim-repeat/zipball/1.0ENH1

1.11	06-Jun-2011
ENH: Support repetition of mappings through repeat.vim.

1.10	12-Jan-2011
Incorporated suggestions by Peter Rincker (thanks for the patch!):
- Made mappings configurable via the customary <Plug> mappings.
- Added mappings gbp, gbP for blockwise pasting.
- Now requires Vim version 7.0 or higher.

1.00	10-Dec-2010
Published, prompted by a related question on reddit.

0.01	10-Apr-2006
Started development, based on vimtip #1199 by cory.

==============================================================================
Copyright: (C) 2006-2022 Ingo Karkat
The VIM LICENSE applies to this plugin; see |copyright|.

Maintainer:	Ingo Karkat <ingo@karkat.de>
==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
